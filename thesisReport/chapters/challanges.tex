\chapter{Challanges of Microservices Architecture}\label{chapter:challanges_of_microservices_architecture}
\section{Introduction}\label{section:challanges_of_microservices_architecture/introduction}
The section \ref{subsection:context/monolith-disadvantages} lists some drawbacks of monolithic architecture and these have become the motivation for adopting microservices architecture. Microservices offer opportunities in various aspects however it can also be tricky to utilize them properly. It do come with few challanges. The response from interview \ref{question:hybris_architecture/interview/question_1.5} also highlights some prominent challanges. In this chapter, the challanges of microservices alongside its advantages will be discussed. \cite{Fowler:2015aa}

  \begin{multicols}{2}
  \textbf{\underline{Advantages}} 
  \vfill
  \columnbreak
  \textbf{\underline{Challanges}}
  \end{multicols}
  \begin{multicols}{2}
  \textbf{Strong Modular Boundaries} \\It is not totally true that monolith have weaker modular structure than microservices but it is also not false to say that as the system gets bigger, it is very easy for monolith to turn in to a big ball of mud. However, it is very difficult to do the same with microservices. Each microservice is a cohesive unit with full control upon its business entities. The only way to access its data is through its \acrshort{API}.
  \vfill
  \columnbreak
  \textbf{Distributed System} \\The infrastructure of microservices is distributed, which brings many complications alongside, as listed by 8 fallacies.\cite{Factor:2014aa} The calls are remote which are imminent to accomplish business goals. The remote calls are slower than local and affect performance in a great deal. Additionally, network is not reliable which makes it challanging to accept and handle the failures.
  \end{multicols}

\begin{multicols}{2}
  \textbf{Independent Deployment} \\Due the nature of microservices being autonomous components, each microservice can be deployed independently. Deployment of microservices is thus easy compared to monolith application where a small change needs the whole system to be deployed.\cite{Newman:2015aa}
  \vfill
  \columnbreak
  \textbf{Integration} \\It is challanging to prevent breaking other microservices when deploying a service. Similarly, as each microservice has its own data, the collaboration among microservices and sharing of data can be complex.
   \end{multicols}
   
  \begin{multicols}{2}
  \textbf{Agile}\\ Each microservice is focused to single responsibility, changes are easy to implement. At the same time, as the microservices are autonomous, they can be deployed independently, making the release cycle time short.
  \vfill
  \columnbreak
  \textbf{Operational Complexity} \\ As the number of microservices increases, it becomes difficult to deploy in an acceptable speed and becomes more complicated as the frequency of changes increase. Similary, as the granularity of microservices decreases, the number of microservices increases which shifts the complexity towards the interconnections. Ultimately, it becomes complex to monitor and debug microservices.
   \end{multicols}

\section{Integration}\label{section:challanges_of_microservices_architecture/integration}
The collaboration among various microservices whilst maintaining deployment autonomy is challenging. In this section, various challanges associated with integration and their potential remedies are discussed.
\subsection{Shared Database}\label{section:challanges_of_microservices_architecture/integration/shared_database}
An easiest way to collaborate, is to allow services to access and update a common data source. However, using this kind of integration creates various problems.\cite{Newman:2015aa}
\begin{enumerate}
\item The shared database acts as a point of coupling among the collaborating microservices. If a microservice make any changes to its data schema, there is high probability that other services need to be changed as well. Loose Coupling is compromised.
\item The business logic related to the shared data may be spread across multiple services. Changing the business logic is difficult. Cohesion is compromised.
\item Multiple services are tied to a single database technology. Migrating to a different technology at any point is hard.
\end{enumerate}
\\
\\
\textbf{Alternatives}\label{section:challanges_of_microservices_architecture/integration/alternatives}
There are three distinct alternatives.\cite{Richardson:2015aa}
\begin{enumerate}
\item \textbf{private tables per service} - multiple services share same database underneath but each service owns a set of tables.
\item \textbf{schema per service} - multiple services share same database however each service owns its own database schema.
\item \textbf{database server per service} - each service has a dedicated database server underneath.
\end{enumerate}
\\
\textbf{Consequences}\label{section:challanges_of_microservices_architecture/integration/consequences}
The logical separation of data among services increases autonomy but also present some downsides.\cite{Richardson:2016aa} \cite{Richardson:2015aa}
\begin{enumerate}
\item The implementation of business transaction which spans multiple services is difficult and not recommended because of \acrshort{CAP} theorem \ref{section:appendices/CAP_theorem}. The solution is to apply eventual consistency \ref{section:appendices/eventual_consistency} focussing more on availability.
\item The implementation of queries to join data from multiple databases can be complicated. There are two alternatives to achieve this.
    \begin{enumerate}
        \item A separate mashup service can be used to handle the logic to join data from multiple services by accessing respective \acrshort{API}s.
        \item \acrshort{CQRS} pattern \ref{section:appendices/CQRS} can be used by maintaining separate views as well as logic for updating and querying data.
    \end{enumerate}
\item The need for sharing data among various autonomous services cannot be avoided completely. It can be achieved by one of the following approaches.
    \begin{enumerate}
        \item The data can be directly accessed by using the resource owner's \acrshort{API}.
        \item The required data can be duplicated into another service and made consistent with the owner's data using event driven approach.
    \end{enumerate}
\end{enumerate}